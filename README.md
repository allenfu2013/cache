# 场景
通常我们会把一些不经常变化，但有经常使用的业务数据放到缓存中去，以提高性能。目前业界使用较多的是缓存中间件是memcache和redis，通常我们会在具体业务逻辑代码中使用他们提供的api进行缓存的操作，比如将数据放入缓存中，或从缓存中获取数据。

# 问题
上面的场景中业务逻辑和缓存逻辑是混在一起，假如未来有更好的缓存中间件可以使用，那么我们需要在所有之前使用过缓存的地方都进行修改。

# 方案
我们能不能把业务逻辑和缓存逻辑区分开来，把缓存逻辑单独出来做成一个系统的缓存模块，未来升级也只是修改这个模块，而使用缓存的人员不需要维护这个模块，他只是使用即可。

# 实现
本项目使用java的annotation定义出一个缓存的注解：@CacheEnable。这个注解使用在需要使用缓存的业务方法上，然后在利用spring aop的拦截机制对h使用了该注解的方法进行拦截。

# 实例

```java

@CacheEnable(opsType=OperationType.GET, key="user", returnType=UserInfo.class, expireSeconds=60000)
public UserInfo getUserInfoById(@KeyParam(connector=":") long id){
  // 业务逻辑
}

```

以上配置会生成缓存的key为"user:"加上查询时实际的id。比如用户id=1，则缓存key就是"user:1"。
因此，缓存模块会在方法执行前先根据key="user:1"去缓存中查询，如果命中则直接将这个值返回给调用方。
如果未命中，则执行方法中的业务方法，之后将得到的值方法缓存中。

## 未完待续
